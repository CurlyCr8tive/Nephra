/**
 * Supabase Service for Nephra
 * 
 * Provides a unified interface for connecting to Supabase
 * and various utility functions for accessing Supabase tables.
 * 
 * Implements Row-Level Security (RLS) awareness in all functions
 * to ensure proper data access control.
 */

import { createClient } from '@supabase/supabase-js';

// Get Supabase credentials from environment variables
const supabaseUrl = process.env.SUPABASE_URL || '';
const supabaseKey = process.env.SUPABASE_KEY || '';

// Types for Supabase tables
export interface HealthLog {
  id?: number;
  user_id: string | number;
  created_at: string;
  bp_systolic: number;
  bp_diastolic: number;
  hydration_level: number;
  pain_level: number;
  stress_level: number;
  fatigue_level: number;
  estimated_gfr?: number | null;
  tags?: string[];
  medications_taken?: string[];
  metadata?: Record<string, any>;
}

export interface ChatLog {
  id?: number;
  user_id: string | number;
  user_input: string;
  ai_response: string;
  model_used?: string;
  timestamp: string;
  tags?: string[];
  emotional_score?: number | null;
  metadata?: Record<string, any>;
}

export interface EducationArticle {
  id?: number;
  title: string;
  summary: string;
  url: string;
  source: string;
  published_date: string;
  category: string;
  user_focus_tags?: string[];
}

console.log("Initializing Supabase client");

// Create a single Supabase client for the application
export const supabase = createClient(supabaseUrl, supabaseKey);

/**
 * RLS Policy Information for Supabase
 * 
 * The following Row-Level Security policies should be set up in Supabase:
 * 
 * For `health_logs` table:
 * - Users can only read their own logs: CREATE POLICY "Users can read own logs" ON health_logs FOR SELECT USING (auth.uid()::text = user_id::text);
 * - Users can only insert their own logs: CREATE POLICY "Users can insert own logs" ON health_logs FOR INSERT WITH CHECK (auth.uid()::text = user_id::text);
 * - Users can only update their own logs: CREATE POLICY "Users can update own logs" ON health_logs FOR UPDATE USING (auth.uid()::text = user_id::text);
 * 
 * For `chat_logs` table:
 * - Users can only read their own chats: CREATE POLICY "Users can read own chats" ON chat_logs FOR SELECT USING (auth.uid()::text = user_id::text);
 * - Users can only insert their own chats: CREATE POLICY "Users can insert own chats" ON chat_logs FOR INSERT WITH CHECK (auth.uid()::text = user_id::text);
 * 
 * For `education_articles` table:
 * - All users can read articles: CREATE POLICY "Public read access" ON education_articles FOR SELECT USING (true);
 * - Only admins can insert/update: CREATE POLICY "Admin insert access" ON education_articles FOR INSERT WITH CHECK (auth.role() = 'admin');
 */

/**
 * Logs a chat interaction to Supabase
 * 
 * @param userId - The user's ID
 * @param userInput - The message sent by the user
 * @param aiResponse - The response generated by the AI
 * @param model - Optional model name (openai, gemini, etc)
 * @param tags - Optional array of tags/keywords
 * @param metadata - Optional additional data
 * @returns The result from Supabase
 */
export async function logChatToSupabase(
  userId: string | number,
  userInput: string,
  aiResponse: string,
  model: string = 'openai',
  tags: string[] = [],
  metadata: any = {}
) {
  try {
    // Convert number userId to string if needed
    const userIdStr = typeof userId === 'number' ? userId.toString() : userId;
    
    const chatData = {
      user_id: userIdStr,
      user_input: userInput,
      ai_response: aiResponse,
      model_used: model,
      timestamp: new Date().toISOString(),
      tags: tags,
      metadata: metadata
    };
    
    console.log("Logging chat to Supabase:", {
      userId: userIdStr,
      inputLength: userInput.length,
      responseLength: aiResponse.length,
      model,
      tags
    });
    
    const { data, error } = await supabase
      .from('chat_logs')
      .insert([chatData])
      .select();
    
    if (error) {
      console.error("Error logging chat to Supabase:", error.message);
      return { success: false, error };
    }
    
    return { success: true, data };
  } catch (error) {
    console.error("Failed to log chat to Supabase:", error);
    return { success: false, error };
  }
}

/**
 * Gets previous chat history for a user from Supabase
 * 
 * @param userId - The user's ID
 * @param limit - Maximum number of records to return
 * @returns Array of chat interactions
 */
export async function getChatHistoryFromSupabase(
  userId: string | number,
  limit: number = 10
) {
  try {
    // Convert number userId to string if needed
    const userIdStr = typeof userId === 'number' ? userId.toString() : userId;
    
    const { data, error } = await supabase
      .from('chat_logs')
      .select('*')
      .eq('user_id', userIdStr)
      .order('timestamp', { ascending: false })
      .limit(limit);
    
    if (error) {
      console.error("Error getting chat history from Supabase:", error.message);
      return [];
    }
    
    return data || [];
  } catch (error) {
    console.error("Failed to get chat history from Supabase:", error);
    return [];
  }
}

/**
 * Gets health logs for a user from Supabase
 * 
 * @param userId - The user's ID
 * @param limit - Maximum number of records to return
 * @returns Array of health log entries
 */
export async function getHealthLogsFromSupabase(
  userId: string | number,
  limit: number = 20
) {
  try {
    // Convert number userId to string if needed
    const userIdStr = typeof userId === 'number' ? userId.toString() : userId;
    
    const { data, error } = await supabase
      .from('health_logs')
      .select('*')
      .eq('user_id', userIdStr)
      .order('created_at', { ascending: false })
      .limit(limit);
    
    if (error) {
      console.error("Error getting health logs from Supabase:", error.message);
      return [];
    }
    
    return data || [];
  } catch (error) {
    console.error("Failed to get health logs from Supabase:", error);
    return [];
  }
}

/**
 * Saves health data to Supabase
 * 
 * @param healthData - The health data to save
 * @returns Success result and data
 */
export async function saveHealthDataToSupabase(healthData: any) {
  try {
    // Ensure created_at is set if not provided
    if (!healthData.created_at) {
      healthData.created_at = new Date().toISOString();
    }
    
    console.log("Saving health data to Supabase:", healthData);
    
    const { data, error } = await supabase
      .from('health_logs')
      .insert([healthData])
      .select();
    
    if (error) {
      console.error("Error saving health data to Supabase:", error.message);
      return { success: false, error };
    }
    
    return { success: true, data };
  } catch (error) {
    console.error("Failed to save health data to Supabase:", error);
    return { success: false, error };
  }
}

/**
 * Checks if Supabase connection is working
 * 
 * @returns Boolean indicating if connection is successful
 */
export async function checkSupabaseConnection(): Promise<boolean> {
  try {
    // Try to connect to Supabase
    const { error } = await supabase
      .from('chat_logs')
      .select('user_id')
      .limit(1);
    
    if (error) {
      console.warn("Supabase connection check failed:", error.message);
      return false;
    }
    
    console.log("‚úÖ Supabase connection successful");
    return true;
  } catch (error) {
    console.error("Supabase connection error:", error);
    return false;
  }
}

/**
 * Log chat with emotional score to Supabase (based on Python implementation)
 * This enhanced version includes emotional scoring and tags
 * 
 * @param userId - User identifier for tracking conversations
 * @param userInput - Message from the user
 * @param aiResponse - Response from the AI
 * @param modelUsed - AI model used ('openai', 'gemini', 'perplexity')
 * @param tags - Optional keywords like ["fatigue", "stress"]
 * @param emotionalScore - Optional stress or fatigue score (1‚Äì10)
 * @returns Response from Supabase
 */
export async function logChatWithEmotionalScore(
  userId: string | number,
  userInput: string,
  aiResponse: string,
  modelUsed: string = "openai",
  tags: string[] = [],
  emotionalScore?: number
): Promise<{success: boolean, data?: any, error?: any}> {
  try {
    // Convert number userId to string if needed
    const userIdStr = typeof userId === 'number' ? userId.toString() : userId;
    
    // Prepare data object
    const data: ChatLog = {
      user_id: userIdStr,
      user_input: userInput,
      ai_response: aiResponse,
      model_used: modelUsed,
      timestamp: new Date().toISOString(),
      tags: tags,
      emotional_score: emotionalScore
    };
    
    console.log(`‚úÖ Logging chat to Supabase for user ${userIdStr} with tags: ${tags.join(', ')}`);
    
    // Insert into Supabase
    const { data: responseData, error } = await supabase
      .from('chat_logs')
      .insert([data])
      .select();
    
    if (error) {
      console.error("‚ùå Error logging chat with emotional score:", error.message);
      return { success: false, error };
    }
    
    return { success: true, data: responseData };
  } catch (error) {
    console.error("‚ùå Failed to log chat with emotional score:", error);
    return { success: false, error };
  }
}

/**
 * Store education articles in Supabase
 * Based on the provided Python implementation
 * 
 * @param articles - List of education articles to store
 * @returns Success status and data or error
 */
export async function storeEducationArticles(
  articles: EducationArticle[]
): Promise<{success: boolean, data?: any, error?: any}> {
  try {
    console.log(`üîÑ Storing ${articles.length} education articles in Supabase`);
    
    const { data, error } = await supabase
      .from('education_articles')
      .insert(articles)
      .select();
    
    if (error) {
      console.error("‚ùå Error storing education articles:", error.message);
      return { success: false, error };
    }
    
    console.log(`‚úÖ Successfully stored ${data.length} education articles`);
    return { success: true, data };
  } catch (error) {
    console.error("‚ùå Failed to store education articles:", error);
    return { success: false, error };
  }
}

/**
 * Search education articles with text query
 * 
 * @param query - Search query
 * @param limit - Maximum number of results to return
 * @returns Matching articles
 */
/**
 * Log health scores to Supabase
 * Based on the provided Python implementation
 * 
 * @param userId - User identifier
 * @param pain - Pain score (0-10)
 * @param stress - Stress score (0-10)
 * @param fatigue - Fatigue score (0-10)
 * @param notes - Optional notes about health status
 * @param additionalData - Any additional data to include
 * @returns Success status and data or error
 */
export async function logHealthScores(
  userId: string | number,
  pain: number,
  stress: number, 
  fatigue: number,
  notes: string = "",
  additionalData: Record<string, any> = {}
): Promise<{success: boolean, data?: any, error?: any}> {
  try {
    // Convert number userId to string if needed
    const userIdStr = typeof userId === 'number' ? userId.toString() : userId;
    
    // Prepare data object following the Python example format
    const data = {
      user_id: userIdStr,
      pain_level: pain,
      stress_level: stress,
      fatigue_level: fatigue,
      notes: notes,
      ...additionalData
    };
    
    console.log(`üîç Logging health scores to Supabase for user ${userIdStr}:`, data);
    
    // Insert into Supabase
    const { data: responseData, error } = await supabase
      .from('health_logs')
      .insert([data])
      .select();
    
    if (error) {
      console.error("‚ùå Supabase insert error:", error);
      return { success: false, error };
    }
    
    console.log("‚úÖ Health scores saved:", responseData);
    return { success: true, data: responseData };
  } catch (error) {
    console.error("‚ùå Failed to log health scores:", error);
    return { success: false, error };
  }
}

export async function searchEducationArticles(
  query: string,
  limit: number = 5
): Promise<EducationArticle[]> {
  try {
    // Split query into words for better matching
    const queryWords = query.toLowerCase().split(/\s+/).filter(word => word.length > 2);
    
    if (queryWords.length === 0) {
      console.warn("Empty search query");
      return [];
    }
    
    console.log(`üîç Searching education articles for: "${query}"`);
    
    // Search in title, summary, and tags
    // Note: This is a basic implementation; for production, use Supabase's full-text search
    const { data, error } = await supabase
      .from('education_articles')
      .select('*')
      .limit(limit);
    
    if (error) {
      console.error("‚ùå Error searching education articles:", error.message);
      return [];
    }
    
    // Filter results client-side by relevance
    // This is a simple implementation - in production, use database full-text search
    const matchedArticles = data.filter(article => {
      const titleMatch = queryWords.some(word => 
        article.title.toLowerCase().includes(word)
      );
      const summaryMatch = queryWords.some(word => 
        article.summary.toLowerCase().includes(word)
      );
      const tagMatch = article.user_focus_tags?.some(tag => 
        queryWords.some(word => tag.toLowerCase().includes(word))
      );
      
      return titleMatch || summaryMatch || tagMatch;
    });
    
    console.log(`‚úÖ Found ${matchedArticles.length} matching articles`);
    return matchedArticles;
  } catch (error) {
    console.error("‚ùå Failed to search education articles:", error);
    return [];
  }
}